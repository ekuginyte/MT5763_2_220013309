---
title: "Individual Assignment 2"
author: "Erna Kuginyte, Student Number 220013309"
date: "30/10/2022"
output: html_document
---

#### Find the R Markdown file at [the GitHub Repository](https://github.com/ekuginyte/MT5763_2_220013309.git)

#### Problem A
##### Initialise

```{r Libraries, include=FALSE}
# Include libraries
library(tidyverse)
library(ggpubr)
```

Monte Carlo Simulation to compute the probability that X > Y , i.e. Pr(X > Y ).

```{r Monte Carlo Simulation}
# Problem A
# Sample size
n <- 1000
# Pre-allocate memory for storing random samples
X <- rep(NA, n)
Y <- rep(NA, n)
prob <- NA
# For reproducibility
set.seed(777)
# Simple Monte Carlo function to calculate probability Pr(X > Y)
# Input:
#  X - samples from normal distribution,
#  Y - samples from uniform distribution.
# Output:
#  prob - probability Pr(X > Y).
my_mc <- function(n) {
  # Generate samples with given boundaries
  X <- rnorm(n, mean = 4, sd = sqrt(10))
  Y <- runif(n, min = 2, max = 8)
  # Compute probability Pr(X > Y) ^[http://ditraglia.com/Econ103Public/Rtutorials/Rtutorial4.html]
  prob <- sum(X > Y) / length(X + Y)
  # I wouldn't use return command normally in this place, since the Tidyverse
  # Style Guide advice against it, unless I wanted the return earlier in the 
  # function. However, I have heard this sometimes gets penalised at the 
  # university, hence, the return command at the end of the function.
  return(prob)
}

# Results
my_mc(n)
```


Bootstrapping method to derive the sampling distribution for the estimate of Pr(X > Y ).

```{r My Bootstrap function}
# Bootstrapping to derive the sampling distribution of Pr(X > Y)
# Sample size
n_repeat <- 10000
# Pre-allocate memory for storing results
boot_res <- rep(NA, n_repeat)
prob_res <- rep(NA, n_repeat)
# For reproducibility
set.seed(555)
# Loop across all samples
# Output:
#  boot_res - store vector of the Pr(X > Y) distribution.
my_bts <- function(n_repeat) {
  for (i in seq(n_repeat)) {
  prob_res[i] <- my_mc(n)
  }
  # Resample with replacement
  boot_res <- sample(x = prob_res, size = n_repeat, replace = TRUE)
  # Store results
  return(boot_res)
}
```

```{r Plot Bootstrap results, echo = FALSE}
res_bts <- my_bts(n_repeat)
res_bts_mean <- mean(res_bts)
# Plot the bootstrap results
ggplot() +
  geom_histogram(aes(x = res_bts), colour = "darkgrey", fill = "aliceblue", 
                 bins = 40) +
  geom_vline(xintercept = res_bts_mean, colour = "deepskyblue4", size = 1) +
  xlab("Count") + ylab("Density") +
  ggtitle("My Bootstrap Result") + 
  theme_minimal()
```


Sample variance changes with the number of Monte Carlo Simulations.

```{r Sample Variance Changes}
# Number of simulations to run
n <- 1000
# Pre-allocate memory to store vector of variances
sample_variances <- rep(NULL, n)
simulation <- rep(NULL, n)
# For reproducibility
set.seed(222)

# Create function to produce variances as number of Monte Carlo simulations
# increase
# Input: 
#  n - number of simulations ran.
# Output:
#  sample_variances - vector of Monte Carlo sample variances.
variance_change <- function(n) {
  # Store multiple values of Monte Carlo simulation probabilities Pr(X > Y)
  for(i in 1:n) {
    simulation[i] <- my_mc(i)
  }
  simulation
  for (i in 1:n) {
    sample_variances[i] <- var(simulation[1:(i + 1)])
    }
  return(sample_variances)
}

# Save variance distribution to p
p <- variance_change(n)
# Sample variance changes plot
ggplot() +
  geom_density(aes(y = p), colour = "darkolivegreen") +
  xlab("Monte Carlo Simulations") +
  ylab("Sample Variance") +
  ggtitle("Sample Variance of The Sampling Distribution") +
  theme_minimal()
```


#### Problem B 


Football tournament. A team keeps playing until they accrue 7 wins or 3 losses (whichever comes first - no draws allowed). Assume a fixed win rate p âˆˆ [0, 1] across all rounds (they are paired at random).

```{r}
# Count number of games the team needs to play to win or loose the match.
# The team needs to accrue 7 wins or 3 losses (no draws). 
# For reproducibility
set.seed(333)
# Input:
#  w - wins to finish the match,
#  l - losses to finish the match.
# Output:
#  game_n - number of games played for the match to be finished.
tournament <- function(prob) {
  # Pre-allocate memory
  games <- NA
  # Assign counter
  w <- 0
  l <- 0
  # Conditions
  wins <- 7
  loses <- 3
  while(w < wins && l < loses) {
    result <- rbinom(1, 1, prob)
    if(result == 1) {
      w <- w + 1
    } 
    else {
      l <- l + 1
    }
  }
  games <- w + l 
  return(games)
}

# Set p values
p <- seq(0, 1, 0.00001)
# Number of times to repeat the function
n <- 1000
# Create function p
p_function <- function(n) {
  # Store results
  result_list <- NULL
  # Run for loop to create p function
  for (i in 1:length(p)) {
    result_list[i] <- tournament(p[i])
  }
  return(result_list)
}
```


Plot how the total number of matches played (i.e. wins + losses) varies as a function of p.

```{r}
# Store results of number of games played to plot
games_played <- p_function(n)

# Function p plot
ggplot() +
  geom_point(aes(x = p, y = games_played), colour = "azure2", alpha = 0.05) +
  geom_smooth(aes(x = p, y = games_played), colour = "darkslateblue") +
  scale_x_continuous(breaks = seq(0, 1, 0.1)) +
  xlab("p") +
  ylab("Games Played") +
  ggtitle("Games Played from Probability of Winning") +
  theme_minimal()
```


Comment on the observed win rate relative to the assumed win rate p (i.e. if a team obtains 2 wins - 3 losses, the maximum likelihood point estimate for their win rate is 40%). Specifically, focus on the effect driven by the format of this tournament.




